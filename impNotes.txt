dev dependences -->  jis me development me kaam aata hai jab deplaoy karte hai toh koi zaraurat nahi hoti
dependences --> hamesha kaam aata hai

folder public/temp --> this is used in order to temperoraly keep the uploaded file in local for uploading because you dont want to be directly uploading because failure can occur at nay time

.env problem with module\


files inside src 
index.js --> main file for running
constant.js --> for keeping all the constants variables 
app.js --> it includes all the app related thing 
folders in src

controllers --> for functionality
db --> for database connection
middlewares --> for verification
models --> for db models
routes --> for routes
utills --> for utility eg . file uploading mailing token lena dena 


installing prettier as a dev dependences

because in professional area same formating is important that is why this is needed
per project bases

we have to add some files

.prettierrc --> for configuration 

.prettierignore --> bcz some files dont need formating like .env bcz it have wierd syntax


lecture 07  Connecting database

mongo db  atlas create account 

create cluster 
create user 
local environment 
add allow all access points 
connect
paste the link in env file

create a db name in constant bcz reusability and onlly chang in one

DataBase Connection

2 approaches 
one full in index 
and other one is db file used


installing mongoose dotenv express

mongoose is used to connec to database and 
error can happen so use try catch every time

1st 
import mongoose 
iffy ;()()
use async
try catch

2nd
new file db write new functio
import in index the execute

import dotenv 
the config give path 
and then 

go to pakage.json then add 
-r dotenv/config --experimental-json-modules

connectdb is async so it return a promise now then the thing is that you have to add .then() and .catch()

create app in app.js then export it 
then after connectdb add it in .then part of code 

imp --> app.use() is used when adding middlewares or configuration file


cors and cookie-parser

app.use(express.json({limit:"16kb"}))   now when the backend accepts only json limit upto only 16 kb

***
(err,res,req,next)

next --> middleware flag ye bolega agr kam hogay toh next middle ware pe jao\
***


higher order function woh func jo kisi  function ko parameter ki tarah accept karsakte hai 
and ya phir ruturn karsaakte hai 

const asyncHandler = (fn) =>async () => {}

now we are making a  miidleware function which is a utility because it is a hectic to make try catch every time when we are making async function now to solve that we have made sure to make a
asyncfunction which will take on the function and then return error if error or return the function if no errror


now make mongoose model user and  Video
index for searching



npm i mongooseAggregatePaginate-v2

and then videoschema.plugin (mongooseAggregatePaginate)

for aggregation pipleine enable using

bcrypt for hashing password 

jwt jsonwebtoken for tokens

.pre data save hone se just pehle ye code chalega 

"save" for saving 
 bcrypt.hash() for hasing 

 if (this.isModified("password"))   +> check if the password is modified 


 Creating custom methods in mongoose 

 userSchema.methods.isPasswordCorrect(){}

 JWT -> bearer token jiske pass ye hai wo allowed hai

 ACCESS_TOKEN_SECRET
 ACCESS_TOKEN_EXPIRY 

 sessions
 cookies 
 
 jwt.sign(payload,accesstoken_secret, expiryobject)


lecture 11

 MULTER
insltall cloudnary
install multer

congifure it and env 

make a util cloudinary 
main work 



this will take  a thing from the local space and then take it and upload it to the next cloudinary
import fs
fs node file system in node 
docs 

fs.unlink - imp  for deleting file 


using multer as a middleware 

storing multer in diskStorage


make controllers
 make route 
 connect route in app 

Register function ---->>>

steps 

take password fullname email username from the req.body
then take avatar img and coverImg 
and then save the everything in db
then genrate access token refresh token
login 

--> 
get users from the frontend 
validate -> check if not empty
check if user exist  : email username 
check for img , avatar exist 
upload images to cloudnary
create user object -> create entry in db
remove pass and rf token from response 
check user creation
return response

import multer upload in to routes

upload .fields(to accept multiple file) inside post before register user 


GENERATE rEFRESH tOKEN AND ACCESS tOKEN

modern practice 
a => short lived 
r => long lived 

create loginUser function 
  // get password and (username or email ) from req.body
  // check for validation not empth
  // find user using username exist or not
  // check password
  // return the user
  // create session refreshToken and accesToken
  // send coolies



  access token ==> short lived 
  refresh token ==> longed lived 

  if 401 hit somtihing and access toke new generation